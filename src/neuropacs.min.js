//prettier-ignore
/*!
 * NeuroPACS v1.0.0
 * (c) 2024 Kerrick Cavanaugh
 * Released under the MIT License.
 */
class Neuropacs{constructor(t,r,e="api"){this.apiKey=r,this.serverUrl=t,this.aesKey=this.#t(),this.orderId="",this.client=e,this.connectionId="",this.datasetUpload=!1}#r=async t=>new Promise(((r,e)=>{const n=new FileReader;n.onload=()=>r(n.result),n.onerror=e,n.readAsArrayBuffer(t)}));#e=(t,r,e=50)=>{const n=t/r*100,a=Array(Math.floor(t/r*e)).fill("=").join("")+Array(e-Math.floor(t/r*e)).fill(".").join("");console.clear(),console.log(`[${a}] ${n.toFixed(2)}%`)};#n=()=>{const t="ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";let r="";for(let e=0;e<20;e++){const e=Math.floor(62*Math.random());r+=t.charAt(e)}return r};#a=()=>Math.random().toString(36).substring(2,15)+Math.random().toString(36).substring(2,15);#t=()=>{const t=new Uint8Array(16);window.crypto.getRandomValues(t);return btoa(String.fromCharCode.apply(null,t))};#o=async t=>{try{t="string"==typeof t?t:JSON.stringify(t)}catch(t){throw{neuropacsError:"Plaintext must be a string or JSON!"}}const r=await this.#i(),e=r.substring(26,r.length-24-1),n=window.atob(e),a=this.#s(n),o=await crypto.subtle.importKey("spki",a,{name:"RSA-OAEP",hash:"SHA-256"},!0,["encrypt"]),i=await crypto.subtle.encrypt({name:"RSA-OAEP"},o,(new TextEncoder).encode(t));return this.#c(i)};#i=async()=>{try{const t=await fetch(`${this.serverUrl}/api/getPubKey/`);if(!t.ok)throw{neuropacsError:`${await t.text()}`};const r=await t.json();return r.pub_key}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Failed to retrieve the public key.")}};#s=t=>{const r=new ArrayBuffer(t.length),e=new Uint8Array(r);for(let r=0,n=t.length;r<n;r++)e[r]=t.charCodeAt(r);return r};#c=t=>{const r=new Uint8Array(t);return btoa(String.fromCharCode.apply(null,r))};#l=async(t,r,e,n)=>{let a;try{if("string"==e&&"string"==typeof t)a=(new TextEncoder).encode(t);else if("JSON"==e){const r=JSON.stringify(t);a=(new TextEncoder).encode(r)}else{if(!("Uint8Array"==e&&t instanceof Uint8Array))throw new Error("Invalid plaintext format!");a=t}}catch(t){throw error?new Error(error):new Error("Plaintext decoding failed!")}try{const t=new Uint8Array(atob(r).split("").map((t=>t.charCodeAt(0)))),e=await this.#d(a,16),o=crypto.getRandomValues(new Uint8Array(16)),i=await crypto.subtle.importKey("raw",t,{name:"AES-CTR"},!1,["encrypt"]),s=await crypto.subtle.encrypt({name:"AES-CTR",counter:o,length:128},i,e),c=new Uint8Array(o.length+s.byteLength);if(c.set(o),c.set(new Uint8Array(s),o.length),"string"===n)return btoa(String.fromCharCode.apply(null,c));if("bytes"===n)return c}catch(t){throw t?new Error(t):new Error("AES encryption failed!")}};#d=async(t,r)=>{const e=r-t.length%r,n=new Uint8Array(t.length+e);return n.set(t),n};#h=async(t,r,e)=>{try{const n=new Uint8Array(atob(r).split("").map((t=>t.charCodeAt(0)))),a=new Uint8Array(atob(t).split("").map((t=>t.charCodeAt(0)))),o=a.slice(0,16),i=a.slice(16),s=await crypto.subtle.importKey("raw",n,{name:"AES-CTR"},!1,["decrypt"]),c=await crypto.subtle.decrypt({name:"AES-CTR",counter:o,length:128},s,i);let l=(new TextDecoder).decode(c);if("JSON"===e)return l=l.trim(),JSON.parse(l);if("string"===e)return l}catch(t){throw t?new Error(t):new Error("AES decryption failed!")}};#p=()=>{const t=new Date;return`${t.getUTCFullYear()}-${String(t.getUTCMonth()+1).padStart(2,"0")}-${String(t.getUTCDate()).padStart(2,"0")} ${String(t.getUTCHours()).padStart(2,"0")}:${String(t.getUTCMinutes()).padStart(2,"0")}:${String(t.getUTCSeconds()).padStart(2,"0")} UTC`};static init(t,r,e="api"){return new Neuropacs(t,r,e)}async connect(){const t={"Content-Type":"text/plain",Client:this.client},r={aes_key:this.aesKey,api_key:this.apiKey};try{const e=await this.#o(r),n=await fetch(`${this.serverUrl}/api/connect/`,{method:"POST",headers:t,body:e});if(!n.ok){throw{neuropacsError:`${JSON.parse(await n.text()).error}`}}const a=(await n.json()).connectionID;return this.connectionId=a,{timestamp:this.#p(),connectionId:a,aesKey:this.aesKey}}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Connection failed!")}}async newJob(){try{const t=`${this.serverUrl}/api/newJob/`,r={"Content-Type":"text/plain","Connection-Id":this.connectionId,Client:this.client},e=await fetch(t,{method:"POST",headers:r});if(!e.ok){throw{neuropacsError:`${JSON.parse(await e.text()).error}`}}const n=await e.text(),a=await this.#h(n,this.aesKey,"string");return this.orderId=a,a}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Job creation failed!")}}async uploadDataset(t,r=null,e=null){try{null==r&&(r=this.orderID);const n=this.#a();this.datasetUpload=!0;const a=t.length;for(let o=0;o<a;o++){const i=t[o];if(201!=await this.upload(i,n,r))throw e&&e({datasetId:n,error:"Dataset upload failed.",progress:-1}),new Error("File upload failed!");if(e){const t=o+1,r=parseFloat((t/a*100).toFixed(2));e({datasetId:n,progress:100==r?100:r,filesUploaded:t})}this.#e(o+1,a)}return n}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Dataset upload failed!")}}async upload(t,r,e=null){null==e&&(e=this.orderId);let n="";if(t instanceof Uint8Array)n=this.#n();else{if(!(t instanceof File))throw{neuropacsError:"Unsupported data type!"};{const r=t instanceof File?t:await this.readFile(t);n=r.name?r.name:this.#n()}}const a=await this.#l(e,this.aesKey,"string","string"),o={"Content-Type":"application/octet-stream","connection-id":this.connectionId,client:this.client,"order-id":a,filename:n,"dataset-id":r},i=await fetch(`${this.serverUrl}/api/uploadRequest/`,{headers:o});if(!i.ok)throw{neuropacsError:`${await i.text()}`};const s=await i.text(),c=(await this.#h(s,this.aesKey,"JSON")).presignedURL,l={"Content-Disposition":"form-data",filename:n},d=new TextEncoder,h=d.encode("neuropacs----------"),p=d.encode(";"),y=d.encode("\r\n"),w=new Uint8Array([...d.encode("--"),...h,...y]),u=new Uint8Array([...d.encode("--"),...h,...d.encode("--"),...y]),f=d.encode("Content-Type: application/octet-stream");let g=w;for(const[t,r]of Object.entries(l)){const e=d.encode(`${t}: ${r}`);g=new Uint8Array([...g,...e,...p])}g=new Uint8Array([...g,...y,...f,...y,...y]);const E=g,A=u;let S;if(t instanceof Uint8Array)S=t;else{if(!(t instanceof File))throw{neuropacsError:"Unsupported data type!"};{const r=await this.#r(t);S=new Uint8Array(r)}}const C=new Uint8Array([...E,...S,...A]),m=await fetch(c,{method:"PUT",body:C});if(!m.ok)throw{neuropacsError:`${await m.text()}`};return 201}async validateUpload(t,r,e=null,n=null){null==e&&(e=this.orderId),null==n&&(n=this.connectionId);try{const n=await this.#l(e,this.aesKey,"string","string"),a=`${this.serverUrl}/api/verifyUpload/`,o={"Content-Type":"text/plain","Dataset-Id":r,"Order-Id":n,"Connection-Id":this.connectionId,Client:this.client},i={fileArray:t},s=await this.#l(i,this.aesKey,"JSON","string"),c=await fetch(a,{method:"POST",headers:o,body:s});if(!c.ok){throw{neuropacsError:`${JSON.parse(await c.text()).error}`}}const l=await c.text();return await this.#h(l,this.aesKey,"JSON")}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Dataset validation failed!")}}async runJob(t,r=null,e=null){null==r&&(r=this.orderId);try{const n=`${this.serverUrl}/api/runJob/`,a={"Content-Type":"text/plain","Connection-Id":this.connectionId,Client:this.client},o={orderID:r,productID:t,datasetID:e},i=await this.#l(o,this.aesKey,"JSON","string"),s=await fetch(n,{method:"POST",headers:a,body:i});if(!s.ok){throw{neuropacsError:`${JSON.parse(await s.text()).error}`}}return s.status}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Job run failed!")}}async checkStatus(t=null,r=null){null==t&&(t=this.orderId);try{const e=`${this.serverUrl}/api/checkStatus/`,n={"Content-Type":"text/plain","Connection-Id":this.connectionId,Client:this.client},a={orderID:t,datasetID:r},o=await this.#l(a,this.aesKey,"JSON","string"),i=await fetch(e,{method:"POST",headers:n,body:o});if(!i.ok){throw{neuropacsError:`${JSON.parse(await i.text()).error}`}}const s=await i.text();return await this.#h(s,this.aesKey,"JSON")}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Status check failed.")}}async getResults(t,r=null,e=null){null==r&&(r=this.orderId);try{const n=`${this.serverUrl}/api/getResults/`,a={"Content-Type":"text/plain","Connection-Id":this.connectionId,Client:this.client};if(!["TXT","XML","JSON"].includes(t))throw{neuropacsError:'Invalid format! Valid formats include: "TXT", "JSON", "XML".'};const o={orderID:r,format:t,datasetID:e},i=await this.#l(o,this.aesKey,"JSON","string"),s=await fetch(n,{method:"POST",headers:a,body:i});if(!s.ok){throw{neuropacsError:`${JSON.parse(await s.text()).error}`}}const c=await s.text();return await this.#h(c,this.aesKey,"string")}catch(t){throw t.neuropacsError?new Error(t.neuropacsError):new Error("Result retrieval failed!")}}}
window.Neuropacs = Neuropacs;
