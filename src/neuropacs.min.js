/*!
 * NeuroPACS v1.0.0
 * (c) 2023 Kerrick Cavanaugh
 * Released under the MIT License.
 */

class Neuropacs {
  constructor(t, e, r) {
    (this.apiKey = t),
      (this.serverUrl = e),
      (this.ackRecieved = !1),
      (this.datasetUpload = !1),
      this.initSocketIO(r);
  }
  loadSocketIOCdn(t, e) {
    var r = document.createElement("script");
    (r.type = "text/javascript"),
      (r.src = t),
      (r.onload = e),
      document.head.appendChild(r);
  }
  disconnectFromSocket() {
    this.socket.close(!1);
  }
  connectToSocket() {
    this.socket.connect();
  }
  async uploadDataset(t, e, r, a) {
    (this.datasetUpload = !0), this.connectToSocket();
    let n = t.length;
    for (let i = 0; i < n; i++) {
      let s = t[i];
      await this.upload(s, e, r, a), this.printProgressBar(i + 1, n);
    }
    return this.disconnectFromSocket(), 201;
  }
  printProgressBar(t, e, r = 50) {
    let a =
      Array(Math.floor((t / e) * r))
        .fill("=")
        .join("") +
      Array(r - Math.floor((t / e) * r))
        .fill(".")
        .join("");
    console.clear(), console.log(`[${a}] ${((t / e) * 100).toFixed(2)}%`);
  }
  async upload(t, e, r, a) {
    (this.ackReceived = !1), this.datasetUpload || this.connectToSocket();
    let n = "";
    if (t instanceof Uint8Array) n = this.generateFilename();
    else if (t instanceof File) {
      let i = t instanceof File ? t : await this.readFile(t);
      n = i.name;
    } else throw Error("Unsupported data type!");
    let s = {
        "Content-Disposition": "form-data",
        filename: n,
        name: "test123"
      },
      o = "neuropacs----------",
      c = "\r\n",
      l = `--${o}${c}`,
      h = `--${o}--${c}`,
      d = l;
    for (let [p, y] of Object.entries(s)) d += `${p}: ${y};`;
    (d += c),
      (d += "Content-Type: application/octet-stream"),
      (d += `${c}${c}`);
    let u = new TextEncoder().encode(d),
      w = await this.encryptAesCtr(e, a, "string"),
      f;
    if (t instanceof Uint8Array) f = this.encryptAesCtr(t, a, "bytes");
    else if (t instanceof File) {
      let C = await this.readFileAsArrayBuffer(t);
      f = await this.encryptAesCtr(new Uint8Array(C), a, "bytes");
    } else throw Error("Unsupported data type!");
    let m = new Uint8Array([...u, ...f, ...new TextEncoder().encode(h)]);
    this.socket.emit("file_data", {
      data: m,
      headers: {
        "Content-Type": "application/octet-stream",
        "connection-id": r,
        client: "API",
        "order-id": w
      }
    });
    let g = Date.now();
    for (; !this.ackReceived && Date.now() - g < 1e4; )
      await new Promise((t) => setTimeout(t, 100));
    return this.datasetUpload || this.disconnectFromSocket(), 201;
  }
  generateFilename() {
    return "generated_filename";
  }
  async readFileAsArrayBuffer(t) {
    return new Promise((e, r) => {
      let a = new FileReader();
      (a.onload = () => e(a.result)), (a.onerror = r), a.readAsArrayBuffer(t);
    });
  }
  initSocketIO(t) {
    this.loadSocketIOCdn(t, () => {
      (this.socket = io(this.serverUrl, {
        autoConnect: !1,
        transports: ["websocket"]
      })),
        this.socket.on("connect", () => {
          console.log("Connected to upload socket!");
        }),
        this.socket.on("ack", (t) => {
          this.ackReceived = !0;
        }),
        this.socket.on("error", (t) => {
          console.error("Socket.IO error:", t);
        });
    });
  }
  generateAesKey() {
    let t = new Uint8Array(16);
    window.crypto.getRandomValues(t);
    let e = btoa(String.fromCharCode.apply(null, t));
    return e;
  }
  async oaepEncrypt(t) {
    try {
      t = JSON.stringify(t);
    } catch (e) {
      if ("string" != typeof t)
        throw Error("Plaintext must be a string or JSON!");
    }
    let r = await getPublicKey(),
      a = new TextEncoder().encode(r),
      n = a.buffer,
      i = await crypto.subtle.importKey(
        "spki",
        n,
        { name: "RSA-OAEP", hash: "SHA-256" },
        !1,
        ["encrypt"]
      ),
      s = new TextEncoder().encode(t),
      o = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, i, s),
      c = Array.from(new Uint8Array(o)),
      l = btoa(String.fromCharCode(...c));
    return l;
  }
  async connect(t, e) {
    let r = await this.oaepEncrypt({ aes_key: e, api_key: t });
    try {
      let a = await fetch(`${this.serverUrl}/connect/`, {
        method: "POST",
        headers: { "Content-Type": "text/plain", client: "api" },
        body: r
      });
      if (a.ok) {
        let n = await a.json(),
          i = n.connectionID;
        return i;
      }
      throw Error(`Connection failed! Status: ${a.status}`);
    } catch (s) {
      throw (console.error(s), Error("Failed to connect to the server."));
    }
  }
  async getPublicKey() {
    try {
      let t = await fetch(`${this.serverUrl}/getPubKey/`);
      if (t.ok) {
        let e = await t.json(),
          r = e.pub_key;
        return r;
      }
      throw Error(`Public key retrieval failed! Status: ${t.status}`);
    } catch (a) {
      throw (console.error(a), Error("Failed to retrieve the public key."));
    }
  }
  async newJob(t, e) {
    try {
      let r = `${this.serverUrl}/newJob/`,
        a = await fetch(r, {
          method: "POST",
          headers: {
            "Content-Type": "text/plain",
            "Connection-Id": t,
            Client: "API"
          }
        });
      if (201 === a.status) {
        let n = await a.text(),
          i = this.decryptAesCtr(n, e, "string");
        return i;
      }
      throw Error(`Job creation returned status ${a.status}.`);
    } catch (s) {
      throw (console.error(s), Error("Failed to create a new job."));
    }
  }
  async runJob(t, e, r, a) {
    try {
      let n = `${this.serverUrl}/runJob/`,
        i = await this.encryptAesCtr({ orderID: e, productID: t }, a, "string"),
        s = await fetch(n, {
          method: "POST",
          headers: {
            "Content-Type": "text/plain",
            "Connection-Id": r,
            Client: "API"
          },
          body: i
        });
      if (202 === s.status) return s.status;
      throw Error("Job run failed.");
    } catch (o) {
      throw Error("Failed to run the job.");
    }
  }
  async checkStatus(t, e, r) {
    try {
      let a = `${this.serverUrl}/checkStatus/`,
        n = await this.encryptAesCtr({ orderID: t }, r, "string"),
        i = await fetch(a, {
          method: "POST",
          headers: {
            "Content-Type": "text/plain",
            "connection-id": e,
            client: "api"
          },
          body: n
        });
      if (200 === i.status) {
        let s = await i.text(),
          o = await this.decryptAesCtr(s, r, "JSON");
        return o;
      }
      throw Error("Status check failed.");
    } catch (c) {
      throw Error("Failed to check status.");
    }
  }
  async getResults(t, e, r, a) {
    try {
      let n = `${this.serverUrl}/getResults/`;
      if (!["TXT", "XML", "JSON", "DICOMSR", "PDF"].includes(t))
        throw Error(
          "Invalid format! Valid formats include: 'TXT', 'JSON', 'XML', 'PDF', 'DICOMSR'."
        );
      let i = this.encryptAesCtr({ orderID: e, format: t }, a, "string"),
        s = await fetch(n, {
          method: "POST",
          headers: {
            "Content-Type": "text/plain",
            "Connection-Id": r,
            Client: "api"
          },
          body: i
        });
      if (200 === s.status) {
        let o = await s.text(),
          c = this.decryptAesCtr(o, a, "string");
        return c;
      }
      throw Error("Result retrieval failed!");
    } catch (l) {
      throw Error("Failed to retrieve results.");
    }
  }
  async oaepEncrypt(t) {
    try {
      t = "string" == typeof t ? t : JSON.stringify(t);
    } catch (e) {
      throw Error("Plaintext must be a string or JSON!");
    }
    let r = await this.getPublicKey(),
      a = r.substring(26, r.length - 24 - 1),
      n = window.atob(a),
      i = this.str2ab(n),
      s = await crypto.subtle.importKey(
        "spki",
        i,
        { name: "RSA-OAEP", hash: "SHA-256" },
        !0,
        ["encrypt"]
      ),
      o = await crypto.subtle.encrypt(
        { name: "RSA-OAEP" },
        s,
        new TextEncoder().encode(t)
      ),
      c = this.arrayBufferToBase64(o);
    return c;
  }
  str2ab(t) {
    let e = new ArrayBuffer(t.length),
      r = new Uint8Array(e);
    for (let a = 0, n = t.length; a < n; a++) r[a] = t.charCodeAt(a);
    return e;
  }
  arrayBufferToBase64(t) {
    let e = new Uint8Array(t);
    return btoa(String.fromCharCode.apply(null, e));
  }
  async encryptAesCtr(t, e, r) {
    let a;
    try {
      let n = JSON.stringify(t);
      a = new TextEncoder().encode(n);
    } catch (i) {
      if ("string" == typeof t) a = new TextEncoder().encode(t);
      else if (t instanceof Uint8Array) a = t;
      else throw Error("Invalid plaintext format!");
    }
    try {
      let s = new Uint8Array(
          atob(e)
            .split("")
            .map((t) => t.charCodeAt(0))
        ),
        o = await this.pad(a, 16),
        c = crypto.getRandomValues(new Uint8Array(16)),
        l = await crypto.subtle.importKey("raw", s, { name: "AES-CTR" }, !1, [
          "encrypt"
        ]),
        h = await crypto.subtle.encrypt(
          { name: "AES-CTR", counter: c, length: 128 },
          l,
          o
        ),
        d = new Uint8Array(c.length + h.byteLength);
      if ((d.set(c), d.set(new Uint8Array(h), c.length), "string" === r))
        return btoa(String.fromCharCode.apply(null, d));
      if ("bytes" === r) return d;
    } catch (p) {
      throw Error("AES encryption failed!");
    }
  }
  async pad(t, e) {
    let r = e - (t.length % e),
      a = new Uint8Array(t.length + r);
    return a.set(t), a;
  }
  async decryptAesCtr(t, e, r) {
    try {
      let a = new Uint8Array(
          atob(e)
            .split("")
            .map((t) => t.charCodeAt(0))
        ),
        n = new Uint8Array(
          atob(t)
            .split("")
            .map((t) => t.charCodeAt(0))
        ),
        i = n.slice(0, 16),
        s = n.slice(16),
        o = await crypto.subtle.importKey("raw", a, { name: "AES-CTR" }, !1, [
          "decrypt"
        ]),
        c = await crypto.subtle.decrypt(
          { name: "AES-CTR", counter: i, length: 128 },
          o,
          s
        ),
        l = new TextDecoder().decode(c);
      if ("JSON" === r) return (l = l.trim()), JSON.parse(l);
      if ("string" === r) return l;
    } catch (h) {
      throw Error("AES decryption failed!");
    }
  }
}
