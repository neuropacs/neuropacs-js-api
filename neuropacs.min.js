export class Neuropacs {
  constructor(t, e) {
    this.t = t;
    this.o = e;
    this.i = false;
    this.h = false;
    this.l();
  }
  u(t, e) {
    var n = document.createElement("script");
    n.type = "text/javascript";
    n.src = t;
    n.onload = e;
    document.head.appendChild(n);
  }
  p() {
    this.A.close(false);
  }
  S() {
    this.A.connect();
  }
  async m(e, n, r, o) {
    this.h = true;
    this.S();
    const s = e.length;
    for (let t = 0; t < s; t++) {
      const a = e[t];
      await this.upload(a, n, r, o);
      this.T(t + 1, s);
    }
    this.p();
    return 201;
  }
  T(t, e, n = 50) {
    const r = (t / e) * 100;
    const o =
      Array(Math.floor((t / e) * n))
        .fill("=")
        .join("") +
      Array(n - Math.floor((t / e) * n))
        .fill(".")
        .join("");
    console.clear();
    console.log(`[${o}] ${r.toFixed(2)}%`);
  }
  async upload(t, e, n, r) {
    this.g = false;
    if (!this.h) {
      this.S();
    }
    let o = "";
    if (t instanceof Uint8Array) {
      o = this.C();
    } else if (t instanceof File) {
      const b = t instanceof File ? t : await this.O(t);
      o = b.name;
    } else {
      throw new Error("Unsupported data type!");
    }
    const s = { P: "form-data", filename: o, name: "test123" };
    const a = "neuropacs----------";
    const c = ";";
    const i = "\r\n";
    const h = `--${a}${i}`;
    const w = `--${a}--${i}`;
    const l = "Content-Type: application/octet-stream";
    let y = h;
    for (const [m, T] of Object.entries(s)) {
      y += `${m}: ${T}${c}`;
    }
    y += i;
    y += l;
    y += `${i}${i}`;
    const d = new TextEncoder().encode(y);
    const f = await this.I(e, r, "string");
    let u;
    if (t instanceof Uint8Array) {
      u = this.I(t, r, "bytes");
    } else if (t instanceof File) {
      const g = await this.U(t);
      u = await this.I(new Uint8Array(g), r, "bytes");
    } else {
      throw new Error("Unsupported data type!");
    }
    const p = new Uint8Array([...d, ...u, ...new TextEncoder().encode(w)]);
    const A = { $: "application/octet-stream", k: n, J: "API", F: f };
    this.A.D("file_data", { data: p, headers: A });
    const E = 10;
    const S = Date.now();
    while (!this.g && Date.now() - S < E * 1e3) {
      await new Promise((t) => setTimeout(t, 100));
    }
    if (!this.h) {
      this.p();
    }
    return 201;
  }
  C() {
    return "generated_filename";
  }
  async U(r) {
    return new Promise((t, e) => {
      const n = new FileReader();
      n.onload = () => t(n.result);
      n.onerror = e;
      n.readAsArrayBuffer(r);
    });
  }
  l() {
    this.u("../lib/socket.io.min.js", () => {
      this.A = io(this.o, { R: false, N: ["websocket"] });
      this.A.v("connect", () => {
        console.log("Connected to upload socket!");
      });
      this.A.v("ack", (t) => {
        this.g = true;
      });
      this.A.v("error", (t) => {
        console.error("Socket.IO error:", t);
      });
    });
  }
  B() {
    const t = new Uint8Array(16);
    window.crypto.getRandomValues(t);
    const e = btoa(String.fromCharCode.apply(null, t));
    return e;
  }
  async K(t) {
    try {
      t = JSON.stringify(t);
    } catch (h) {
      if (typeof t !== "string") {
        throw new Error("Plaintext must be a string or JSON!");
      }
    }
    const e = await getPublicKey();
    const n = new TextEncoder().encode(e);
    const r = n.buffer;
    const o = await crypto.subtle.importKey(
      "spki",
      r,
      { name: "RSA-OAEP", hash: "SHA-256" },
      false,
      ["encrypt"]
    );
    const s = new TextEncoder().encode(t);
    const a = await crypto.subtle.encrypt({ name: "RSA-OAEP" }, o, s);
    const c = Array.from(new Uint8Array(a));
    const i = btoa(String.fromCharCode(...c));
    return i;
  }
  async connect(t, e) {
    const n = { $: "text/plain", J: "api" };
    const r = { M: e, j: t };
    const o = await this.K(r);
    try {
      const a = await fetch(`${this.o}/connect/`, {
        method: "POST",
        headers: n,
        body: o
      });
      if (a.ok) {
        const c = await a.json();
        const i = c.L;
        return i;
      } else {
        throw new Error(`Connection failed! Status: ${a.status}`);
      }
    } catch (s) {
      console.error(s);
      throw new Error("Failed to connect to the server.");
    }
  }
  async X() {
    try {
      const e = await fetch(`${this.o}/getPubKey/`);
      if (e.ok) {
        const n = await e.json();
        const r = n._;
        return r;
      } else {
        throw new Error(`Public key retrieval failed! Status: ${e.status}`);
      }
    } catch (t) {
      console.error(t);
      throw new Error("Failed to retrieve the public key.");
    }
  }
  async H(t, e) {
    try {
      const r = `${this.o}/newJob/`;
      const o = { $: "text/plain", Y: t, G: "API" };
      const s = await fetch(r, { method: "POST", headers: o });
      if (s.status === 201) {
        const a = await s.text();
        const c = this.V(a, e, "string");
        return c;
      } else {
        throw new Error(`Job creation returned status ${s.status}.`);
      }
    } catch (n) {
      console.error(n);
      throw new Error("Failed to create a new job.");
    }
  }
  async q(t, e, n, r) {
    try {
      const s = `${this.o}/runJob/`;
      const a = { $: "text/plain", Y: n, G: "API" };
      const c = { W: e, Z: t };
      const i = await this.I(c, r, "string");
      const h = await fetch(s, { method: "POST", headers: a, body: i });
      if (h.status === 202) {
        return h.status;
      } else {
        throw new Error("Job run failed.");
      }
    } catch (o) {
      throw new Error("Failed to run the job.");
    }
  }
  async tt(t, e, n) {
    try {
      const o = `${this.o}/checkStatus/`;
      const s = { $: "text/plain", k: e, J: "api" };
      const a = { W: t };
      const c = await this.I(a, n, "string");
      const i = await fetch(o, { method: "POST", headers: s, body: c });
      if (i.status === 200) {
        const h = await i.text();
        const w = await this.V(h, n, "JSON");
        return w;
      } else {
        throw new Error("Status check failed.");
      }
    } catch (r) {
      throw new Error("Failed to check status.");
    }
  }
  async et(t, e, n, r) {
    try {
      const s = `${this.o}/getResults/`;
      const a = { $: "text/plain", Y: n, G: "api" };
      const c = ["TXT", "XML", "JSON", "DICOMSR", "PDF"];
      if (!c.includes(t)) {
        throw new Error(
          "Invalid format! Valid formats include: 'TXT', 'JSON', 'XML', 'PDF', 'DICOMSR'."
        );
      }
      const i = { W: e, format: t };
      const h = this.I(i, r, "string");
      const w = await fetch(s, { method: "POST", headers: a, body: h });
      if (w.status === 200) {
        const l = await w.text();
        const y = this.V(l, r, "string");
        return y;
      } else {
        throw new Error("Result retrieval failed!");
      }
    } catch (o) {
      throw new Error("Failed to retrieve results.");
    }
  }
  async K(t) {
    try {
      t = typeof t === "string" ? t : JSON.stringify(t);
    } catch (w) {
      throw new Error("Plaintext must be a string or JSON!");
    }
    const e = await this.X();
    const n = "-----BEGIN PUBLIC KEY-----";
    const r = "-----END PUBLIC KEY-----";
    const o = e.substring(n.length, e.length - r.length - 1);
    const s = window.atob(o);
    const a = this.nt(s);
    const c = await crypto.subtle.importKey(
      "spki",
      a,
      { name: "RSA-OAEP", hash: "SHA-256" },
      true,
      ["encrypt"]
    );
    const i = await crypto.subtle.encrypt(
      { name: "RSA-OAEP" },
      c,
      new TextEncoder().encode(t)
    );
    const h = this.rt(i);
    return h;
  }
  nt(n) {
    const t = new ArrayBuffer(n.length);
    const r = new Uint8Array(t);
    for (let t = 0, e = n.length; t < e; t++) {
      r[t] = n.charCodeAt(t);
    }
    return t;
  }
  rt(t) {
    const e = new Uint8Array(t);
    return btoa(String.fromCharCode.apply(null, e));
  }
  async I(t, e, n) {
    let r;
    try {
      const s = JSON.stringify(t);
      r = new TextEncoder().encode(s);
    } catch (o) {
      if (typeof t === "string") {
        r = new TextEncoder().encode(t);
      } else if (t instanceof Uint8Array) {
        r = t;
      } else {
        throw new Error("Invalid plaintext format!");
      }
    }
    try {
      const a = new Uint8Array(
        atob(e)
          .split("")
          .map((t) => t.charCodeAt(0))
      );
      const c = await this.pad(r, 16);
      const i = crypto.getRandomValues(new Uint8Array(16));
      const h = await crypto.subtle.importKey(
        "raw",
        a,
        { name: "AES-CTR" },
        false,
        ["encrypt"]
      );
      const w = await crypto.subtle.encrypt(
        { name: "AES-CTR", ot: i, length: 128 },
        h,
        c
      );
      const l = new Uint8Array(i.length + w.byteLength);
      l.set(i);
      l.set(new Uint8Array(w), i.length);
      if (n === "string") {
        return btoa(String.fromCharCode.apply(null, l));
      } else if (n === "bytes") {
        return l;
      }
    } catch (o) {
      throw new Error("AES encryption failed!");
    }
  }
  async pad(t, e) {
    const n = e - (t.length % e);
    const r = new Uint8Array(t.length + n);
    r.set(t);
    return r;
  }
  async V(e, n, r) {
    try {
      const o = new Uint8Array(
        atob(n)
          .split("")
          .map((t) => t.charCodeAt(0))
      );
      const s = new Uint8Array(
        atob(e)
          .split("")
          .map((t) => t.charCodeAt(0))
      );
      const a = s.slice(0, 16);
      const c = s.slice(16);
      const i = await crypto.subtle.importKey(
        "raw",
        o,
        { name: "AES-CTR" },
        false,
        ["decrypt"]
      );
      const h = await crypto.subtle.decrypt(
        { name: "AES-CTR", ot: a, length: 128 },
        i,
        c
      );
      let t = new TextDecoder().decode(h);
      if (r === "JSON") {
        t = t.trim();
        return JSON.parse(t);
      } else if (r === "string") {
        return t;
      }
    } catch (t) {
      throw new Error("AES decryption failed!");
    }
  }
}
